class i{static async get(e){return new Promise(t=>{chrome.storage.local.get(e,r=>t(r[e]||null))})}static async set(e,t){return new Promise(r=>{chrome.storage.local.set({[e]:t},r)})}static async remove(e){return new Promise(t=>{chrome.storage.local.remove(e,t)})}static async getMultiple(e){return new Promise(t=>{chrome.storage.local.get(e,r=>{const s={};for(const o of e)s[o]=r[o]||null;t(s)})})}static async removeMultiple(e){return new Promise(t=>{chrome.storage.local.remove(e,t)})}}const E="https://api.github.com",n={GITHUB_TOKEN:"githubToken",ACTIVE_ISSUE:"activeIssue",START_TIME:"startTime",TRACKED_TIMES:"trackedTimes",ISSUES:"issues"},y=a=>`⏱️ Tracked time: **${a}**`;class h{static async getGitHubToken(){return i.get(n.GITHUB_TOKEN)}static async setGitHubToken(e){return i.set(n.GITHUB_TOKEN,e)}static async removeGitHubToken(){return i.remove(n.GITHUB_TOKEN)}static async validateGitHubToken(e){try{return(await fetch("https://api.github.com/user",{headers:{Authorization:`token ${e}`}})).ok}catch(t){return console.error("Token validation failed:",t),!1}}}class T{static parseIssueUrl(e){const t=e.match(/^\/([^/]+)\/([^/]+)\/issues\/(\d+)/);if(!t)throw new Error("Invalid GitHub issue URL");return{owner:t[1],repo:t[2],issueNumber:parseInt(t[3],10),fullRepo:`${t[1]}/${t[2]}`}}static async apiRequest(e,t={}){const r=await h.getGitHubToken();if(!r)throw new Error("GitHub token not found");const s=await fetch(`${E}${e}`,{...t,headers:{Authorization:`token ${r}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json",...t.headers}});if(!s.ok){const o=await s.json();throw new Error(o.message||"GitHub API request failed")}return s.json()}static async getUser(){return this.apiRequest("/user")}static async postComment({owner:e,repo:t,issueNumber:r,seconds:s}){const o=Math.floor(s/60),c=Math.floor(s%60),l=o>0?`${o} min${c>0?` ${c} sec`:""}`:`${c} sec`;return this.apiRequest(`/repos/${e}/${t}/issues/${r}/comments`,{method:"POST",body:JSON.stringify({body:y(l)})})}}const u=n.ISSUES;class I{static async getAll(){return await i.get(u)||[]}static async add(e){const t=await this.getAll();t.some(s=>s.url===e.url)||(t.push(e),await i.set(u,t))}static async update(e,t){const s=(await this.getAll()).map(o=>o.url===e?{...o,...t}:o);await i.set(u,s)}static async remove(e){const r=(await this.getAll()).filter(s=>s.url!==e);await i.set(u,r)}static async removeAll(){await i.remove(n.ISSUES)}static async getByUrl(e){return(await this.getAll()).find(r=>r.url===e)||null}static async exists(e){return(await this.getAll()).some(r=>r.url===e)}static async clear(){await i.remove(u)}}async function g(a){const{activeIssue:e,startTime:t,trackedTimes:r}=await i.getMultiple([n.ACTIVE_ISSUE,n.START_TIME,n.TRACKED_TIMES]);if(e&&t){const s=(Date.now()-new Date(t).getTime())/1e3,o=await I.getByUrl(e);console.log(`Stopped due to ${a}. Tracked ${s} seconds on ${e}`);let c;try{c=T.parseIssueUrl(e)}catch(m){console.error("Failed to parse issue URL:",m);return}const{owner:l,repo:p,issueNumber:S}=c,w=(o==null?void 0:o.title)||"Untitled",d=r||[];if(d.push({issueUrl:e,title:w,seconds:s,date:new Date().toISOString().slice(0,10)}),await i.set(n.TRACKED_TIMES,d),await h.getGitHubToken())try{await T.postComment({owner:l,repo:p,issueNumber:S,seconds:s})}catch(m){console.error("Failed to post comment:",m)}await i.removeMultiple([n.ACTIVE_ISSUE,n.START_TIME])}}chrome.runtime.onStartup.addListener(async()=>{await g("browser restart")});chrome.runtime.onSuspend.addListener(async()=>{await g("browser closing")});chrome.runtime.onMessage.addListener((a,e,t)=>{console.log("Background received message:",a),(a.action==="timerStarted"||a.action==="timerStopped")&&(chrome.tabs.query({url:"*://github.com/*"},r=>{r.forEach(s=>{chrome.tabs.sendMessage(s.id,a,o=>{chrome.runtime.lastError?console.log(`Failed to send message to tab ${s.id}:`,chrome.runtime.lastError.message):console.log(`Message sent to tab ${s.id}, response:`,o)})})}),t({received:!0}))});
