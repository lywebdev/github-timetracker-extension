class d{static formatTime(t,e=0){const n=Math.floor(t+e),o=Math.floor(n/3600),r=Math.floor(n%3600/60),c=Math.floor(n%60);return`${o.toString().padStart(2,"0")}:${r.toString().padStart(2,"0")}:${c.toString().padStart(2,"0")}`}static timeStringSince(t,e=0){const n=new Date(t);if(isNaN(n.getTime()))return this.formatTime(0,e);const o=Math.floor((Date.now()-n.getTime())/1e3);return this.formatTime(o,e)}static splitSeconds(t){return{minutes:Math.floor(t/60),seconds:Math.floor(t%60)}}}const q="https://api.github.com",s={GITHUB_TOKEN:"githubToken",ACTIVE_ISSUE:"activeIssue",START_TIME:"startTime",TRACKED_TIMES:"trackedTimes",ISSUES:"issues"},x=1e3,L=a=>`⏱️ Tracked time: **${a}**`;class i{static async get(t){return new Promise(e=>{chrome.storage.local.get(t,n=>e(n[t]||null))})}static async set(t,e){return new Promise(n=>{chrome.storage.local.set({[t]:e},n)})}static async remove(t){return new Promise(e=>{chrome.storage.local.remove(t,e)})}static async getMultiple(t){return new Promise(e=>{chrome.storage.local.get(t,n=>{const o={};for(const r of t)o[r]=n[r]||null;e(o)})})}static async removeMultiple(t){return new Promise(e=>{chrome.storage.local.remove(t,e)})}}class R{static async getGitHubToken(){return i.get(s.GITHUB_TOKEN)}static async setGitHubToken(t){return i.set(s.GITHUB_TOKEN,t)}static async removeGitHubToken(){return i.remove(s.GITHUB_TOKEN)}static async validateGitHubToken(t){try{return(await fetch("https://api.github.com/user",{headers:{Authorization:`token ${t}`}})).ok}catch(e){return console.error("Token validation failed:",e),!1}}}class b{static parseIssueUrl(t){const e=t.match(/^\/([^/]+)\/([^/]+)\/issues\/(\d+)/);if(!e)throw new Error("Invalid GitHub issue URL");return{owner:e[1],repo:e[2],issueNumber:parseInt(e[3],10),fullRepo:`${e[1]}/${e[2]}`}}static async apiRequest(t,e={}){const n=await R.getGitHubToken();if(!n)throw new Error("GitHub token not found");const o=await fetch(`${q}${t}`,{...e,headers:{Authorization:`token ${n}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json",...e.headers}});if(!o.ok){const r=await o.json();throw new Error(r.message||"GitHub API request failed")}return o.json()}static async getUser(){return this.apiRequest("/user")}static async postComment({owner:t,repo:e,issueNumber:n,seconds:o}){const r=Math.floor(o/60),c=Math.floor(o%60),l=r>0?`${r} min${c>0?` ${c} sec`:""}`:`${c} sec`;return this.apiRequest(`/repos/${t}/${e}/issues/${n}/comments`,{method:"POST",body:JSON.stringify({body:L(l)})})}}const f=s.ISSUES;class ${static async getAll(){return await i.get(f)||[]}static async add(t){const e=await this.getAll();e.some(o=>o.url===t.url)||(e.push(t),await i.set(f,e))}static async update(t,e){const o=(await this.getAll()).map(r=>r.url===t?{...r,...e}:r);await i.set(f,o)}static async remove(t){const n=(await this.getAll()).filter(o=>o.url!==t);await i.set(f,n)}static async removeAll(){await i.remove(s.ISSUES)}static async getByUrl(t){return(await this.getAll()).find(n=>n.url===t)||null}static async exists(t){return(await this.getAll()).some(n=>n.url===t)}static async clear(){await i.remove(f)}}class k{static async getTotalTimeForIssue(t){return(await i.get(s.TRACKED_TIMES)||[]).filter(n=>n.issueUrl===t).reduce((n,o)=>n+(o.seconds||0),0)}static async startTimer(t,e=null){try{const[n,o,r]=await Promise.all([i.get(s.ACTIVE_ISSUE),i.get(s.START_TIME),$.getByUrl(t)]);n&&o&&n!==t&&(console.log(`Останавливаем таймер для предыдущей задачи: ${n}`),await this.stopTimer(n,e));const c=b.parseIssueUrl(t),{owner:l,repo:u,issueNumber:w}=c,y=this.getIssueTitle()||"Untitled",E=`(${l}) ${u} | ${y} | #${w}`;await Promise.all([i.set(s.ACTIVE_ISSUE,t),i.set(s.START_TIME,new Date().toISOString())]),r||await $.add({url:t,title:E});const g=await this.getTotalTimeForIssue(t);let h=null;return e&&(e.textContent=`${d.formatTime(0,g)} ⏸ Stop`,h=window.setInterval(async()=>{const p=await i.get(s.START_TIME);if(!p||isNaN(new Date(p).getTime())){clearInterval(h),e.textContent=`${d.formatTime(0,g)} Start Timer`;return}e.textContent=`${d.timeStringSince(p,g)} ⏸ Stop`},x),e.dataset.intervalId=h.toString()),{issueUrl:t,totalTime:g,intervalId:h,isRunning:!0}}catch(n){return console.error("Не удалось запустить таймер:",n),e!=null&&e.dataset.intervalId&&(clearInterval(parseInt(e.dataset.intervalId,10)),e.textContent="Start Timer"),await i.removeMultiple([s.ACTIVE_ISSUE,s.START_TIME]),{issueUrl:t,totalTime:0,intervalId:null,isRunning:!1}}}static getLocalDateString(){const t=new Date,e=t.getFullYear(),n=String(t.getMonth()+1).padStart(2,"0"),o=String(t.getDate()).padStart(2,"0");return`${e}-${n}-${o}`}static async stopTimer(t,e=null){try{const[n,o,r,c]=await Promise.all([i.get(s.START_TIME),R.getGitHubToken(),i.get(s.TRACKED_TIMES),$.getByUrl(t)]);if(!n||isNaN(new Date(n).getTime()))return console.error("Некорректное startTime:",n),this.resetButtonState(e),await i.removeMultiple([s.ACTIVE_ISSUE,s.START_TIME]),{issueUrl:t,totalTime:0,isRunning:!1};const l=(c==null?void 0:c.title)||"Untitled",u=Math.floor((Date.now()-new Date(n).getTime())/1e3),w=b.parseIssueUrl(t),{owner:y,repo:E,issueNumber:g}=w;if(o)try{await b.postComment({owner:y,repo:E,issueNumber:g,seconds:u})}catch(j){console.error("Не удалось отправить комментарий:",j)}const h=[...r||[],{issueUrl:t,title:l,seconds:u,date:this.getLocalDateString()}];await Promise.all([i.set(s.TRACKED_TIMES,h),i.removeMultiple([s.ACTIVE_ISSUE,s.START_TIME])]);const p=await this.getTotalTimeForIssue(t);return this.resetButtonState(e,p),{issueUrl:t,totalTime:p,isRunning:!1}}catch(n){return console.error("Не удалось остановить таймер:",n),this.resetButtonState(e),{issueUrl:t,totalTime:0,isRunning:!1}}}static getIssueTitle(){var t,e,n,o;return((e=(t=document.querySelector("span.js-issue-title"))==null?void 0:t.textContent)==null?void 0:e.trim())||((o=(n=document.querySelector("[data-testid='issue-title']"))==null?void 0:n.textContent)==null?void 0:o.trim())||null}static resetButtonState(t,e=0){t!=null&&t.dataset.intervalId&&(clearInterval(parseInt(t.dataset.intervalId,10)),delete t.dataset.intervalId),t&&(t.textContent=`${d.formatTime(0,e)} Start Timer`)}}function P(a,t){const e=(n,o)=>{o==="local"&&n[a]&&t(n[a].newValue)};return chrome.storage.onChanged.addListener(e),()=>chrome.storage.onChanged.removeListener(e)}console.log("injectTimerButton module loaded, timestamp:",Date.now());let I=!1;function M(){console.log("resetInjectedFlag: resetting isInjected"),I=!1}async function O(){if(!G()){console.log("injectTimerButton: skipped (not an issue page)");return}const a=document.querySelector('[data-testid="issue-metadata-fixed"]'),t=document.querySelector("#track-time-btn");if(!a||t||I){console.log(`injectTimerButton: skipped (container: ${!!a}, buttonExists: ${!!t}, isInjected: ${I})`);return}const e=document.querySelectorAll("#track-time-btn");e.forEach(c=>{c.dataset.intervalId&&clearInterval(c.dataset.intervalId),c.remove()}),console.log(`injectTimerButton: removed ${e.length} existing buttons`);const n=H();I=!0;const o=async()=>{if(!document.querySelector("#track-time-btn")){console.log("updateButton: button not found, skipping update");return}console.log("updateButton: fetching storage data");const{activeIssue:c,startTime:l}=await A(),u=await k.getTotalTimeForIssue(location.pathname)||0;c===location.pathname&&l&&!isNaN(new Date(l).getTime())?(B(n,l,u),n.dataset.intervalId||K(n,u)):(n.textContent=`${d.formatTime(0,u)} Start Timer`,n.dataset.intervalId&&(clearInterval(n.dataset.intervalId),delete n.dataset.intervalId))};a.append(n),console.log("injectTimerButton: button appended"),await o(),n.addEventListener("click",async()=>{console.log("track-time-btn clicked");const{activeIssue:c,startTime:l}=await A();c===location.pathname&&l&&!isNaN(new Date(l).getTime())?await k.stopTimer(location.pathname,n):await k.startTimer(location.pathname,n),await o()});const r=P(s.TRACKED_TIMES,()=>{console.log("storageListener: trackedTimes changed"),o()});window.addEventListener("unload",()=>{console.log("injectTimerButton: cleaning up"),n.dataset.intervalId&&(clearInterval(n.dataset.intervalId),delete n.dataset.intervalId),r(),I=!1})}function G(){return location.pathname.match(/^\/[^/]+\/[^/]+\/issues\/\d+$/)}function H(){const a=document.createElement("button");return a.id="track-time-btn",a.style.marginTop="10px",a.className="btn btn-sm",a.textContent="Start Timer",a}async function A(){return new Promise(a=>{chrome.storage.local.get([s.ACTIVE_ISSUE,s.START_TIME],t=>{a({activeIssue:t[s.ACTIVE_ISSUE]||null,startTime:t[s.START_TIME]||null})})})}function B(a,t,e){a.textContent=`${d.timeStringSince(t,e)} ⏸ Stop`}function K(a,t){const e=setInterval(async()=>{if(!document.querySelector("#track-time-btn")){clearInterval(e),delete a.dataset.intervalId;return}const{startTime:n}=await A();n&&!isNaN(new Date(n).getTime())?B(a,n,t):(a.textContent=`${d.formatTime(0,t)} Start Timer`,clearInterval(e),delete a.dataset.intervalId)},x);a.dataset.intervalId=e}console.log("content script loaded, timestamp:",Date.now());function V(a,t){let e;return(...n)=>{clearTimeout(e),e=setTimeout(()=>a(...n),t)}}function S(){return location.pathname.match(/^\/[^/]+\/[^/]+\/issues\/\d+$/)}const v=V(O,500);function T(a=10,t=500){console.log(`checkContainer: attempts left ${a}, pathname: ${location.pathname}`);const e=document.querySelector('[data-testid="issue-metadata-fixed"]');if(document.querySelector("#track-time-btn")){console.log("checkContainer: button already exists, skipping");return}if(e||a<=0){console.log("checkContainer: injecting button, container found:",!!e),v();return}setTimeout(()=>T(a-1,t),t)}function F(){i.getMultiple([s.ACTIVE_ISSUE,s.START_TIME]).then(({activeIssue:a,startTime:t})=>{S()&&a===location.pathname&&t&&!isNaN(new Date(t).getTime())&&(document.querySelector("#track-time-btn")||(console.log("Timer is active for current page, injecting button"),T()))})}S()&&(T(),setInterval(F,2e3));let m=location.pathname;const N=new MutationObserver(()=>{location.pathname!==m&&(console.log(`MutationObserver: pathname changed from ${m} to ${location.pathname}`),M(),m=location.pathname,S()&&T())});N.observe(document.body,{childList:!0,subtree:!0});const C=new MutationObserver(()=>{document.querySelector("#track-time-btn")||(console.log("containerObserver: container changed"),v())}),_=document.querySelector('[data-testid="issue-metadata-fixed"]');_&&(console.log("containerObserver: initial container found"),C.observe(_,{childList:!0}));const D=new MutationObserver(()=>{const a=document.querySelector('[data-testid="issue-metadata-fixed"]'),t=document.querySelector("#track-time-btn");a&&!t&&(console.log("bodyObserver: new container found"),C.observe(a,{childList:!0}),v())});D.observe(document.body,{childList:!0,subtree:!0});window.addEventListener("popstate",()=>{location.pathname!==m&&(console.log(`popstate: pathname changed to ${location.pathname}`),M(),m=location.pathname,S()&&T())});const U=history.pushState;history.pushState=function(...a){U.apply(this,a),location.pathname!==m&&(console.log(`pushState: pathname changed to ${location.pathname}`),M(),m=location.pathname,S()&&T())};chrome.runtime.onMessage.addListener((a,t,e)=>{console.log("Received message:",a),(a.action==="timerStarted"||a.action==="timerStopped")&&(console.log(`Processing ${a.action} for issueUrl: ${a.issueUrl}, current pathname: ${location.pathname}`),S()&&a.issueUrl===location.pathname?document.querySelector("#track-time-btn")||(console.log("Updating timer button on current issue page"),document.querySelector('[data-testid="issue-metadata-fixed"]')?(console.log("Container found, injecting button"),v()):(console.log("Container not found, retrying with checkContainer"),T(15,500))):console.log("Message ignored: not on matching issue page or not an issue page"),e({received:!0}))});window.addEventListener("unload",()=>{console.log("unload: cleaning up observers and pushState"),N.disconnect(),C.disconnect(),D.disconnect(),history.pushState=U});
